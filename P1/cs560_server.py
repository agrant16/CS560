#!/usr/bin/python3
"""
Names: Alan Grant, Dustin Mcafee
Class: COSC 560 - Advanced Operating Systems
Assignment: Programming Assignment 1 - Basic HTTP Server

This module contains two classes: CS560Handler and CS560Server. These two 
classes have been implemented as a solution to Programming Assignment 1 for
COSC 560 - Advanced Operating Systems at the University of Tennesee - Knoxville.
Combined the two classes create a basic HTTP server capabale of handling GET 
and HEAD requests. It is capable of serving the following static file types:

    - TEXT FILES
        + HTML
        + CSS
        + PLAIN TEXT
    - IMAGES
        + PNG
        + GIF
        + JPEG
        + X-ICON
    
"""
import cgi
import http.server
import os
import pathlib
import platform
import socket
import sys
import threading
import time

# Supported static content types
mimetypes = {'.html': 'text/html',
             '.htm': 'text/html',
             '.css': 'text/css',
             '.jpg': 'image/jpeg',
             '.jpeg': 'image/jpeg',
             '.png': 'image/png',
             '.gif': 'image/gif',
             '.txt': 'text/plain',
             '.ico': 'image/x-icon'}
             

class CS560Handler(object):
    """Custom request handler class. 
    
    This class is capable of handling the content types listed in the 
    above mimetypes dictionary."""
    
    
    def handle(self, method, fp, response, browser):
        """Base handler function for parsing requests and returning the 
        proper content. 
        
        Processes incoming requests and returns proper content. There are three 
        possiblities here:
        
            1. method=='GET'. The contents of the file and the proper headers 
               are retrieved.
               
            2. method=='HEAD'. Similar to method=='GET' except that only the 
               heades are sent.
               
            3. method is neither 'GET' or 'HEAD'. Build a basic webpage based 
               around a 405 error code and sends this as the content. 
        
        Args:
            method (str) : The type of request (GET, HEAD, POST, etc.)
            fp (str) : The file path to the requested content. 
            response (list) : Used for storing values for use after thread
                              completion. 
            browser (str) : The browser being used to access the server.
        """                      
        if method == 'GET':
            headers, content = self.do_GET(fp, browser)
            response.extend([headers, content])
        elif method == 'HEAD':
            headers, content = self.do_GET(fp, browser)
            response.extend([headers,''])
        else:
            content = ('<!doctype=html>\n<html>\n\t<body>\n\t\t<h1>Unsupported'
                        ' Request Method</h1>\n\t\t</br></br>\n\t\t<a href="./'
                        'index.html">Back to front page.</a>\n\t</body>\n'
                        '</html>').encode()
            headers = self.gen_headers(405, os.getsizeof(content), '.html')
            response.extend([headers, content])


    def do_GET(self, fp, browser):
        """ Processes GET and HEAD requests.
        
        This function process GET requests and handles those requests 
        appropriately. There are four possibilities that are supported for GET 
        requests:
        
            1. The requested content is a supported static file. In this case
               the function retrieves the contents of the file. 
               
            2. The requested content is a directory. Here self.list_dir() is 
               called to dynamically generate a link page of the contents of 
               the directory. 
               
            3. The request contains a query string. In this case the client has
               submitted a form or performed some other action which requires
               the execution of a CGI script. self.run_script() is called and 
               the page generated by the script is retrieved. 
               
            4. The requested content is not found. A basic html page is created 
               to display the 404 error. 
               
        Args:
            fp (str) : The filepath to the requested content. 
            browser (str) : The browser being used to access the server.       
        
        Returns:
            headers (bytes) : The proper headers for the content in bytes format.
            content (bytes) : The requested content in bytes format. 
        """
        content = ''
        ctype = '.html'
        try:
            fp = '.' + fp
            if '?' in fp: # contains a query string run cgi script
                content = self.run_script(fp)
            elif pathlib.Path(fp).is_file(): # retrieve the contents of the file
                with open(fp, 'rb') as f:
                    content = f.read()
                    ctype = pathlib.Path(fp).suffix
            elif pathlib.Path(fp).is_dir(): # request is a directory
                content = self.list_dir(fp, browser)
            headers = self.gen_headers(200, sys.getsizeof(content), ctype)
        except IOError: # Can't open the requested content. 
            content = ('<!doctype=html>\n<html><body><h1>404 File Not Found'
                        '</h1></body></html>').encode()
            headers = self.gen_headers(404, os.getsizeof(content), ctype)
        return headers, content
 
         
    def gen_headers(self,  code, length, ctype):
        """ Generates HTTP response headers.
        
        Handles three possible response codes:
            
            1. 200 - Content is found and response is good.
            
            2. 404 - Content is not found.
            
            3. 405 - Unsupported request method was received. 
            
        Headers are sent in the following format:
        
            HTTP/1.1 {code}
            Connection: {connection response}
            Date: {current date time}
            Content-Type: {mimetype of requested content}
            Server: Alan and Dustin's CS560 Server {Server OS}
            
        Args:
            code (int) : Response code for the header.
            length (int) : Length of content in bytes. 
            ctype (str) : The content type, used to find the proper mimetype. 
            
        Returns:
            h (bytes) : The headers as a bytes object.
        """

        h = 'HTTP/1.1 ' # Every header starts with this. 
        # determine response code
        if (code == 200):
            h += '200 OK\n'
            h += 'Connection: keep-alive\ns'
        elif(code == 404):
            h = '404 Not Found\n'
            h += 'Connection: close\n'
        elif(code == 405):
            h += '405 Unsupported Request Method\n'
            h += 'Connection: close\n'
        h += 'Date: {}\n'.format(time.strftime("%a, %d %b %Y %H:%M:%S", 
                                 time.localtime()))
        h += 'Content-Type: {}\n'.format(mimetypes.get(ctype))
        h += ('Server: Alan and Dustin\'s CS560 Server ({})\n\n'
             .format(platform.platform()))
        return h.encode()
      
    
    def run_script(self, fp):
        """Handles running of basic CGI scripts using GET requests.
        
        This function handles running CGI scripts. With a GET request the 
        submitted data is sent as a sequence of (id, value) pairs in the
        following form:
        
            id1=value1&id2=value2&id3=value3
            
        We take this string and assign it to the environment variable 
        'QUERY_STRING' which allows us to access this data in a CGI script. 
        The appropriate script is then run and the output of the script 
        (generally an HTML page) is returned as the content.
        
        Args:
            fp (str) : The filepath to the requested content. 
            
        Returns:
            content (bytes) : The HTML page generated by the CGI script. 
        """
        fp, query = fp.split('?')
        os.environ['QUERY_STRING'] = query
        content = os.popen(fp).read()
        return content.encode()
  
  
    def list_dir(self, my_dir, browser):
        """Lists the contents of a directory as a simple HTML page.
        
        Creates a basic HTML page listing the contents of the given directory. 
        A link is created to each item in the directory. Firefox and Chrome 
        are supported browsers. The building of directory links is handled 
        differently for each browser because Chrome and Firefox handle 
        directory links differently. 
        
        Args:
            my_dir (str) : The filepath to the requested directory.
            browser (str) : The browser being used to access the server.
                        
        Returns:
            content (bytes) : The directory listing as an HTML page in bytes 
                           format.
        """
        # Basic html page with placeholders for inserting links later. 
        dir_listing = ('<!doctype=html>\n<html lang="en"><head>'
                       '<meta charset="utf-8">\n<title>Alan & Dustin\'s '
                       'Webserver</title>\n<meta name="description" '
                       'content="Alan & Dustin\'s Webserver">\n</head>\n'
                       '<body>\n<h1>{0}</h1>\n<ul>\n{1}\n</ul>\n</body>\n'
                       '</html>\n')
                       
        # Store the links in a list for insertion into the unordered list 
        # on the web page. 
        ul = ['<li><a href="../">../</a></li>\n']
        for e in os.listdir(my_dir):
            is_d = os.path.isdir(os.path.join(my_dir, e))
            if is_d:
                if browser == 'firefox':
                    ul.append('<li><a href="{0}/{1}/">{2}/</a></li>\n'
                              .format(my_dir, e, e))
                elif browser == 'chrome':
                    ul.append('<li><a href="{0}/">{1}/</a></li>\n'
                              .format(e, e))                
            elif my_dir == './server' and not is_d:
                ul.append('<li><a href="{0}/{1}">{2}</a></li>\n'
                          .format(my_dir, e, e))
            else:
                ul.append('<li><a href="{0}">{1}</a></li>\n'.format(e, e))
        # Join the links with a linefeed and carriage return and insert 
        # them into the webpage.         
        content = dir_listing.format(my_dir[1:], '\n'.join(ul))
        return content.encode()   
        
        
class CS560Server(object):
    """ Simple socket server which uses CS560Handler to act as a basic HTTP 
    server.
    
    Creates a connection on localhost at the given port and runs the webserver
    from the current directory.
    
    Args:
        port (int) : The port the server is to listen on.
    
    Attributes:
        host (str) : The hostname the server is running on (we use localost).
        port (int) : The port the server is to listen on.
        handler (CS560Handler) : The request handler used to retreive content. 
    """


    def __init__(self, port):
        self.host = '127.0.0.1'
        self.port = port
        self.handler = CS560Handler()
        
        
    def start_server(self):
        """ Function to start the server running.
        
        This function attempts to open a connection with self.port and bind 
        that connection to (self.host, self.port). If port is successfully 
        connected to we begin serving content to that port forever. If the 
        port cannot be connected to, we report this to the user and shutdown 
        the server. 
        """
        try:
            print('Starting server on {}...'.format(self.port))
            self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.s.bind((self.host, self.port))
            print('Port acquired. Listening...')
            print('Press CTRL+C to shutdown server.\n')
            self.serve_forever()
        except OSError as e:
            print("Warning: Could not acquire port:", self.port,"\n")
            
        
    def shutdown(self):
        """Basic shutdown function to close the open socket."""
        self.s.shutdown(socket.SHUT_RDWR)


    def serve_forever(self):
        """ Main loop of the socket server.
        
        This function provides the main loop for the server. Here we constantly 
        listen at self.port and wait for a request to come in. When a request is
        received we collect it and begin the parsing process. 
        """
        while True:
            self.s.listen(5)
            conn, addr = self.s.accept()
            message = conn.recv(1024)                        
            if not message:
                continue
            else:
                request = bytes.decode(message) #receive data from client
                print(str(request))
                headers, content = self.parse_request(request)
                print(bytes.decode(headers))
                conn.sendall(headers + content)
                conn.close()
     
    def get_browser(self, request):
        """ Parses the client's browser from the request."
        
        Args:
            request (list) : The request split apart to individual elements.
        
        Returns:
            browser (str) : The browser the client is using. 
        """
        for x in request:
            if x[0] == 'User-Agent:':
                for y in x:
                    if 'Chrome' in y:
                        browser = 'chrome'
                        break
                    else:
                        browser = 'firefox'
        return browser


    def parse_request(self, request):
        """Performs initial request parsing.
        
        This function performs initial requesting handling by parsing out the
        request method and the requested content. Once this is done it spawns a 
        new Thread to handle the request. This allows for concurrent request 
        handling. 
        
        Args:
            request (str) : HTTP request in str format.
            
        Returns:
            response (list) : Python list containing the response headers and 
                              requested content. 
        """
        r = request.split('\r\n')
        request = r[0].split(' ')
        r2 = [r.split(' ') for r in r]
        browser = self.get_browser(r2)
        
        method = request[0]
        if request[1] == '/':
            f = '/index.html'
        else:
            f = request[1]
        response = []
        t = threading.Thread(target=self.handler.handle, 
                             args=(method, f, response, browser))
        t.start()
        t.join()
        return response
        
        
# Execute this code if the program is run as an executable.                 
if __name__ == '__main__':
    port = 8080
    try:
        if len(sys.argv) > 1:
            port = sys.argv[1]
        server = CS560Server(port)
        server.start_server()
    except KeyboardInterrupt:
        print(' pressed.')
        print('Server is shutting down.')
        server.shutdown()
